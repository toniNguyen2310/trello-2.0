import { passLocalStorage } from "@utils/passLocalStorage";
import axios from "axios";

// Base URL t·ª´ file `.env`
const baseURL = import.meta.env.VITE_BACKEND_URL;

const instance = axios.create({
    baseURL: baseURL + "/api/",
});

// T√™n key l∆∞u user info trong localStorage
export const STORAGE_KEY = "user_info";

// Header ƒë·ªÉ tr√°nh retry l·∫∑p l·∫°i
const NO_RETRY_HEADER = "x-no-retry";

// C√°c domain n·ªôi b·ªô ƒë·ªÉ th√™m delay (ch·ªâ trong dev)
const isLocalApi = ["127.0.0.1", "localhost"].some((domain) =>
    baseURL.includes(domain)
);

// ‚è±Ô∏è Delay trong local ƒë·ªÉ d·ªÖ debug
const delayIfLocal = () =>
    isLocalApi ? new Promise((res) => setTimeout(res, 200)) : Promise.resolve();

const redirectToLogin = () => {
    clearUserInfo();
    window.location.href = "/login";
};

const getUserInfo = () => passLocalStorage.getItem(STORAGE_KEY);
const setUserInfo = (data) => passLocalStorage.setItem(STORAGE_KEY, data);
const clearUserInfo = () => passLocalStorage.removeItem(STORAGE_KEY);

// üîÑ G·ª≠i request refresh token
const refreshToken = async () => {
    const refreshToken = getUserInfo()?.refreshToken;
    const res = await instance.post("/auth/refresh-token", { refreshToken });
    return res?.data;
};

// üîë G·∫Øn access token v√†o header
const setAccessToken = () => {
    const accessToken = getUserInfo()?.accessToken;

    if (accessToken) {
        instance.defaults.headers.common["Authorization"] = `Bearer ${accessToken}`;
    }
};


instance.interceptors.request.use(
    async (config) => {
        const accessToken = getUserInfo()?.accessToken;
        if (accessToken) {
            config.headers.Authorization = `Bearer ${accessToken}`;
        }
        return config;
    },
    (error) => Promise.reject(error)
);

// üî• Interceptor Response
instance.interceptors.response.use(
    async (response) => {
        await delayIfLocal();
        return response?.data;
    },
    async (error) => {
        const originalRequest = error.config;

        // ‚ùó N·∫øu 401 v√† ch∆∞a retry l·∫ßn n√†o
        if (
            error.response?.status === 401 &&
            !originalRequest.headers[NO_RETRY_HEADER]
        ) {
            try {
                const data = await refreshToken();

                if (data?.accessToken && data?.refreshToken) {
                    // L∆∞u l·∫°i token m·ªõi
                    const newInfo = {
                        ...getUserInfo(),
                        accessToken: data.accessToken,
                        refreshToken: data.refreshToken,
                    };
                    setUserInfo(newInfo);

                    // G·∫Øn l·∫°i token m·ªõi
                    originalRequest.headers["Authorization"] = `Bearer ${data.accessToken}`;
                    originalRequest.headers[NO_RETRY_HEADER] = "true";

                    return instance.request(originalRequest); // g·ª≠i l·∫°i request
                }
            } catch (refreshError) {
                clearUserInfo();
                redirectToLogin();
            }
        }

        // ‚ùå N·∫øu refresh token c≈©ng h·∫øt h·∫°n
        if (
            error.response?.status === 400 &&
            originalRequest?.url === "/auth/refresh-token"
        ) {
            clearUserInfo();
            redirectToLogin();
            return Promise.reject(error);
        }

        await delayIfLocal();

        return Promise.reject(error?.response?.data || error);
    }
);

export default instance;
